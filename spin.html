<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel of Names</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap');
        
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #f3f4f6;
            overflow-x: hidden;
        }

        .arrow-down {
            width: 0; 
            height: 0; 
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 40px solid #1f2937;
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
        }

        .wheel-container {
            position: relative;
            display: block; 
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            background: white;
            border-radius: 50%;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin: 0 auto;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-10 px-4">

    <h1 class="text-3xl font-bold text-gray-800 mb-2">üé° ‡∏ß‡∏á‡∏•‡πâ‡∏≠‡∏™‡∏∏‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠</h1>
    <p class="text-gray-600 mb-8">‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏•‡∏¢!</p>

    <div class="flex flex-col lg:flex-row gap-10 items-start w-full max-w-5xl justify-center">
        
        <!-- ‡∏™‡πà‡∏ß‡∏ô‡∏ß‡∏á‡∏•‡πâ‡∏≠ (Responsive) -->
        <div class="flex flex-col items-center order-2 lg:order-1 flex-1 w-full">
            <div class="wheel-container relative">
                <div class="arrow-down"></div>
                <canvas id="wheelCanvas" width="800" height="800" class="w-full h-full rounded-full"></canvas>
            </div>
            
            <div id="result" class="mt-6 text-2xl font-bold text-indigo-600 h-10 transition-all duration-300 transform text-center">
                ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô...
            </div>

            <!-- Action Buttons for Result -->
            <div id="winnerActions" class="hidden mt-4 flex flex-wrap gap-3 justify-center w-full">
                <!-- ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ -->
                <button onclick="removeWinner()" class="bg-red-500 hover:bg-red-600 text-white py-3 px-6 rounded-full shadow-lg transition text-base flex items-center gap-2 transform active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    ‡∏•‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å
                </button>
                
                <!-- ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡πà‡∏≠ (‡πÑ‡∏°‡πà‡∏•‡∏ö) -->
                <button onclick="spin()" class="bg-gray-600 hover:bg-gray-700 text-white py-3 px-6 rounded-full shadow-lg transition text-base flex items-center gap-2 transform active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    ‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡πà‡∏≠ (‡πÑ‡∏°‡πà‡∏•‡∏ö)
                </button>
            </div>

            <button onclick="spin()" id="spinBtn" class="mt-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-12 rounded-full shadow-lg transform transition active:scale-95 text-xl">
                ‡∏´‡∏°‡∏∏‡∏ô‡∏ß‡∏á‡∏•‡πâ‡∏≠!
            </button>
        </div>

        <!-- ‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ -->
        <div class="w-full lg:w-80 bg-white p-6 rounded-xl shadow-md order-1 lg:order-2 shrink-0">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="nameInput">
                ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏•‡∏∞ 1 ‡∏ä‡∏∑‡πà‡∏≠)
            </label>
            <textarea id="nameInput" rows="10" 
                class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md p-3 border"
                oninput="handleInput()">
‡πÄ‡∏à
‡∏ö‡∏¥‡∏ß
‡πÅ‡∏ô‡∏ô
‡∏Å‡∏≠‡∏•‡πå‡∏ü
‡∏™‡πâ‡∏°
‡πÄ‡∏≠
‡∏ö‡∏µ
‡∏ã‡∏µ
</textarea>
            <div class="mt-2 text-xs text-gray-500 text-right">
                <span id="count">8</span> ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠
            </div>
            <div class="mt-4 flex gap-2">
                 <button onclick="shuffleNames()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 px-4 rounded text-sm transition">
                    ‡∏™‡∏•‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                </button>
                <button onclick="clearNames()" class="flex-1 bg-red-100 hover:bg-red-200 text-red-800 py-2 px-4 rounded text-sm transition">
                    ‡∏•‡πâ‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                </button>
            </div>
            
            <div class="mt-4 flex items-center justify-end">
                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="soundToggle" class="sr-only peer" checked>
                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    <span class="ms-3 text-sm font-medium text-gray-700">‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå</span>
                </label>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const resultDiv = document.getElementById('result');
        const winnerActions = document.getElementById('winnerActions');
        
        let width = canvas.width; 
        let height = canvas.height;
        let centerX = width / 2;
        let centerY = height / 2;
        let radius = width / 2 - 20;

        let names = [];
        let currentAngle = 0;
        let isSpinning = false;
        let animationId = null;
        let currentWinner = ""; 
        
        let audioCtx = null;
        let lastSliceIndex = -1;

        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
            '#FFEEAD', '#FFCC5C', '#FF9671', '#D4A5A5', 
            '#9B59B6', '#3498DB', '#E67E22', '#2ECC71'
        ];

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTickSound() {
            if (!document.getElementById('soundToggle').checked || !audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); 
            oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.05);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.05);
        }

        function playWinSound() {
            if (!document.getElementById('soundToggle').checked || !audioCtx) return;
            const notes = [523.25, 659.25, 783.99, 1046.50]; 
            const now = audioCtx.currentTime;
            notes.forEach((freq, i) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                gainNode.gain.setValueAtTime(0, now + i * 0.1);
                gainNode.gain.linearRampToValueAtTime(0.2, now + i * 0.1 + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.5);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start(now + i * 0.1);
                oscillator.stop(now + i * 0.1 + 0.6);
            });
        }

        function getNames() {
            const text = document.getElementById('nameInput').value;
            const list = text.split('\n').filter(n => n.trim() !== '');
            document.getElementById('count').innerText = list.length;
            return list;
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ UI ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
        function handleInput() {
            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏õ
            resetGameUI(); 
            drawWheel();
        }

        function resetGameUI() {
            winnerActions.classList.add('hidden');
            resultDiv.innerText = "‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô...";
            resultDiv.className = "mt-6 text-2xl font-bold text-indigo-600 h-10 transition-all duration-300 transform text-center";
            // Show main spin button again if it was hidden (though we keep it visible usually)
            spinBtn.classList.remove('hidden'); 
        }

        function drawWheel() {
            names = getNames();
            // REMOVED: The logic that automatically hid buttons based on isSpinning.
            // Now drawWheel ONLY draws. UI state is managed by spin() and handleInput().

            if (names.length === 0) {
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#f3f4f6';
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#9ca3af';
                ctx.font = '40px Sarabun'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö', centerX, centerY);
                return;
            }

            const sliceAngle = (2 * Math.PI) / names.length;

            ctx.clearRect(0, 0, width, height);

            names.forEach((name, i) => {
                const startAngle = i * sliceAngle + currentAngle;
                const endAngle = (i + 1) * sliceAngle + currentAngle;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                
                ctx.lineWidth = 2; 
                ctx.strokeStyle = '#ffffff';
                ctx.stroke();

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + sliceAngle / 2);
                ctx.textAlign = "right";
                ctx.fillStyle = "#ffffff"; // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
                ctx.textBaseline = "middle";
                
                const arcLengthAtRim = (radius - 40) * sliceAngle;
                let fontSize = arcLengthAtRim * 0.75;

                if (fontSize > 56) fontSize = 56; 
                if (fontSize < 20) fontSize = 20; 

                ctx.font = `bold ${fontSize}px Sarabun, sans-serif`;
                
                const maxTextWidth = radius - 100; 
                let textWidth = ctx.measureText(name).width;
                
                if (textWidth > maxTextWidth) {
                    let lengthBasedSize = fontSize * (maxTextWidth / textWidth);
                    if (lengthBasedSize < fontSize) fontSize = lengthBasedSize;
                }
                
                ctx.font = `bold ${fontSize}px Sarabun, sans-serif`;
                ctx.shadowColor = "rgba(0,0,0,0.5)"; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡πÄ‡∏á‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô
                ctx.shadowBlur = 4;
                ctx.fillText(name, radius - 40, 0); 
                ctx.restore();
            });

            ctx.beginPath();
            ctx.arc(centerX, centerY, 60, 0, 2 * Math.PI); 
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#e5e7eb';
            ctx.stroke();
            
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#F59E0B";
            ctx.shadowColor = "transparent";
            ctx.fillText("‚òÖ", centerX, centerY + 4);
        }

        function spin() {
            initAudio();
            if (isSpinning) return;
            
            names = getNames();
            if (names.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            // Reset UI state specifically for a new spin
            resetGameUI();
            
            // Hide main spin button temporarily while spinning to avoid double clicks
            // (Optional, but looks cleaner)
            spinBtn.classList.add('hidden');

            isSpinning = true;
            resultDiv.innerText = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏°‡∏∏‡∏ô...";
            resultDiv.className = "mt-6 text-2xl font-bold text-gray-500 text-center";

            const spinAngle = (Math.random() * 5 + 5) * 2 * Math.PI; 
            const duration = 4000 + Math.random() * 2000; 
            
            const startAngle = currentAngle;
            let startTime = null;
            lastSliceIndex = -1; 

            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                
                if (elapsed < duration) {
                    const t = elapsed / duration;
                    const easeOut = 1 - Math.pow(1 - t, 3);
                    
                    currentAngle = startAngle + (spinAngle * easeOut);
                    
                    const normalizedAngle = currentAngle % (2 * Math.PI);
                    const sliceAngle = (2 * Math.PI) / names.length;
                    
                    const angleAtPointer = (3 * Math.PI / 2 - normalizedAngle + 2 * Math.PI) % (2 * Math.PI);
                    const currentSliceIndex = Math.floor(angleAtPointer / sliceAngle);

                    if (lastSliceIndex !== -1 && currentSliceIndex !== lastSliceIndex) {
                        playTickSound();
                    }
                    lastSliceIndex = currentSliceIndex;

                    currentAngle = currentAngle % (2 * Math.PI); 
                    
                    drawWheel();
                    animationId = requestAnimationFrame(animate);
                } else {
                    isSpinning = false;
                    
                    currentAngle = startAngle + spinAngle;
                    currentAngle = currentAngle % (2 * Math.PI);
                    drawWheel();
                    
                    calculateWinner();
                    playWinSound(); 
                }
            }

            animationId = requestAnimationFrame(animate);
        }

        function calculateWinner() {
            const sliceAngle = (2 * Math.PI) / names.length;
            let normalizedAngle = currentAngle % (2 * Math.PI);
            if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;

            let pointerValue = (3 * Math.PI / 2) - normalizedAngle;
            if (pointerValue < 0) pointerValue += 2 * Math.PI;
            pointerValue = pointerValue % (2 * Math.PI);

            const index = Math.floor(pointerValue / sliceAngle);
            currentWinner = names[index] || names[0];

            resultDiv.innerText = "üéâ ‡∏ú‡∏π‡πâ‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ‡∏Ñ‡∏∑‡∏≠: " + currentWinner + " üéâ";
            resultDiv.className = "mt-6 text-3xl font-bold text-pink-600 animate-bounce text-center";
            
            // Show Action Buttons
            winnerActions.classList.remove('hidden');
            // Hide main spin button to force user to choose (Remove or Spin Again)
            spinBtn.classList.add('hidden');
            
            createConfetti();
        }

        function removeWinner() {
            if (!currentWinner) return;
            
            let currentNames = getNames();
            const newNames = currentNames.filter(name => name !== currentWinner);
            
            document.getElementById('nameInput').value = newNames.join('\n');
            
            // Reset UI after removal
            resetGameUI();
            
            resultDiv.innerText = "‡∏•‡∏ö " + currentWinner + " ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!";
            resultDiv.className = "mt-6 text-xl text-gray-500 text-center";
            
            drawWheel();
        }

        function shuffleNames() {
            let list = getNames();
            for (let i = list.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [list[i], list[j]] = [list[j], list[i]];
            }
            document.getElementById('nameInput').value = list.join('\n');
            resetGameUI(); // Reset if shuffled
            drawWheel();
        }

        function clearNames() {
            if(confirm('‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏´‡∏°?')) {
                document.getElementById('nameInput').value = '';
                resetGameUI();
                drawWheel();
            }
        }
        
        function createConfetti() {
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff'];
            for(let i=0; i<50; i++) {
                setTimeout(() => {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random()*5, 0, Math.PI*2);
                    ctx.fill();
                }, i * 20);
            }
            setTimeout(drawWheel, 1500);
        }

        window.onload = drawWheel;

    </script>
</body>
</html>
